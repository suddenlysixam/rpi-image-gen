#!/usr/bin/env python

import json
import re
import argparse
import os
import copy
import sys
import subprocess


VERSION = "2.2.0"


IMAGE_KEYS = {"IGconf_device_class",
              "IGconf_device_variant",
              "IGconf_device_storage_type",
              "IGconf_device_sector_size",
              "IGconf_image_version",
              "IGconf_image_outputdir"}


IMAGE_KEY_TYPES = {
    "IGconf_device_sector_size": int,
    # add more as needed
}


top_template = {
    "IGversion": VERSION,
    "IGmeta": [],
    "attributes": {
        "image-name": "unknown",
        "image-size": 0,
        "image-palign-bytes": "unknown",
    },
    "layout": {
        "partitiontable": [],
        "partitionimages": [],
        "provisionmap": []
    }
}


partition_template =  {
    "name": "default",
    "in-partition-table": "true",
}


# mke2fs specifies the UUID with -U
def get_extfs_uuid(extraargs):
    match = re.search(r"-U\s+([a-fA-F0-9\-]+)", extraargs)
    return match.group(1).lower() if match else None


# mkdosfs specifies volume ID with -i
def get_vfat_uuid(extraargs):
    match = re.search(r"-i\s+([a-fA-F0-9\-]+)", extraargs)
    if match:
        uuid = match.group(1).upper()
        return f"{uuid[:4]}-{uuid[4:]}"
    return None


# genimage key value mapping
def map_genimage(key, value):
    gmap = {
        # https://github.com/pengutronix/genimage#the-image-section
        "partition-type-uuid":{
            ("L", "linux"):       "0FC63DAF-8483-4772-8E79-3D69D8477DE4",
            ("S", "swap"):        "0657FD6D-A4AB-43C4-84E5-0933C84B4F4F",
            ("H", "home"):        "933AC7E1-2EB4-4F13-B844-0E14E2AEF915",
            ("U", "esp", "uefi"): "C12A7328-F81F-11D2-BA4B-00A0C93EC93B",
            ("R", "raid"):        "A19D880F-05FC-4D3B-A006-743F0F84911E",
            ("V", "lvm"):         "E6D6D379-F507-44C2-A23C-238F2A3DF928",
            ("F", "fat32"):       "EBD0A0A2-B9E5-4433-87C0-68B6B72699C7"
        }
    }
    if key in gmap:
        translations = gmap[key]
        for possible_values, translated_value in translations.items():
            if value in possible_values:
                return translated_value

    return value


# General single line based key value reader with options
def read_kv(line, exclude_keys=None, translate_fn=None):
    if exclude_keys is None:
        exclude_keys = set() # Default - no exclusions

    for match in re.finditer(r"^\s*([\w-]+)\s*=\s*(\"[^\"]*\"|'[^']*'|[^#\n]+)", line, re.MULTILINE):
        key, value = match.groups()
        if key in exclude_keys:
            return (None, None)

        value = value.strip().strip('"').strip("'") # Remove quotes if present

        if translate_fn:
            value = translate_fn(key, value)

    return (key, value)


# Convert a libconfuse struct to nested dictionary with optional translate
# function and exclude filter for key value pairs
def confuse2dict(config_path, exclude_keys=None, tfn=None):
    with open(config_path, "r") as f:
        lines = f.readlines()

    root_structure = {}
    section_stack = [root_structure]

    # Match entry of section - type and optional subtype
    section_delimiter = r"([a-zA-Z0-9\-]+)(?:\s+([^\s]+))?\s*\{"

    for line in lines:
        line = line.strip()

        # remove any comments
        line = re.sub(r"\s*#.*", "", line).strip()
        if line == "" or not line:
            continue

        section = re.search(section_delimiter, line)
        if section:
            section_type = section.group(1)
            section_subtype = section.group(2)

            new_section = {}

            if section_subtype:
                if section_type not in section_stack[-1]:
                    section_stack[-1][section_type] = {} # new
                section_stack[-1][section_type][section_subtype] = new_section
                section_stack.append(new_section)
            else:
                section_stack[-1][section_type] = new_section
                section_stack.append(new_section)

            if '}' in line: # end of section on same line
                section_stack.pop()

            continue

        if "}" in line: # end of section
            if len(section_stack) > 1:
                section_stack.pop()
            else:
                raise ValueError("Unexpected closing brace")
            continue

        key, value = read_kv(line, exclude_keys, tfn)
        if key and value:
            if section_stack:
                section_stack[-1][key] = value

    if len(section_stack) != 1:
        raise ValueError("Parse error. Mismatched brace?")

    return root_structure


# Recursive find all sections by type
def find_sections(stype, data, sections=None):
    if sections is None:
        sections = {}

    for k, v in data.items():
        if isinstance(v, dict):
            if k == stype:
                for name, data in v.items():
                    sections[name] = data
            else:
                find_sections(stype, v, sections)
    return sections


# Find all images by type
def find_images(itype, data):
    timages = {}
    images = find_sections("image", data)
    for iname, iattr in images.items():
        if itype in iattr:
            timages[iname] = iattr
    return timages


# Returns the path of a build asset. If the asset is not an absolute path, use
# the env var as the directory of where to look.
def get_artefact_path(file, dir_evar):
    if not os.path.isabs(file):
        dir = os.getenv(dir_evar)
        if not dir:
            raise ValueError(f"Not an env var: {dir_evar}")
            return None

        if not os.path.isdir(dir):
            raise FileNotFoundError(f"Dir not found: {dir}")
            return None

        fpath = os.path.join(dir, file)
    else:
        fpath = file

    if not os.path.isfile(fpath):
        raise FileNotFoundError(f"File not found: {fpath}")
        return None

    return fpath


# Returns the size of a build artefact file.
def get_artefact_size(file):
    f = get_artefact_path(file, "IGconf_image_outputdir")
    if f:
        return os.stat(f).st_size
    return None


def get_fs_label(section):
    label = section.get("label")
    if label:
        return label
    return None


def process_extfs(section):
    args = section.get("extraargs", "")
    values = {
        "fs_uuid": get_extfs_uuid(args),
        "fs_label": get_fs_label(section)
    }
    return {k: v for k, v in values.items() if v is not None}


def process_vfat(section):
    args = section.get("extraargs", "")
    values = {
        "fs_uuid": get_vfat_uuid(args),
        "fs_label": get_fs_label(section)
    }
    return {k: v for k, v in values.items() if v is not None}


IMAGE_PROCESSORS = {
    "vfat":  process_vfat,
    "ext2":  process_extfs,
    "ext3":  process_extfs,
    "ext4":  process_extfs,
    "btrfs": process_extfs
}


def parse_genimage_config(config_path):
    data = confuse2dict(config_path, {"exec-pre", "exec-post"}, map_genimage)

    # Anchor to hdimage as it's the root container of a disk image
    # https://github.com/pengutronix/genimage/?tab=readme-ov-file#hdimage
    hdimage_data = find_images("hdimage", data)
    if not hdimage_data:
        return (None,None,None)

    disk_attr = {}
    ptable = {}

    partitions = find_sections("partition", hdimage_data)
    images = find_sections("image", data)
    simgs = find_images("android-sparse", data)

    for img_name, img_data in hdimage_data.items():
        hdimage = img_data.get("hdimage")
        disk_attr["image-name"] = img_name
        disk_attr["image-size"] = hdimage.get("size") if hdimage.get("size") else 0
        disk_attr["image-palign"] = hdimage.get("align") if hdimage.get("align") else "0"
        sz = get_artefact_size(img_name)
        if sz:
            disk_attr["image-size"] = sz

    # https://github.com/pengutronix/genimage?tab=readme-ov-file#the-image-configuration-options
    gtypes = ["android-sparse", "btrfs", "cpio", "cramfs", "ext2", "ext3",
              "ext4", "f2fs", "file", "FIT", "fip", "flash", "iso", "jffs2",
              "qemu", "rauc", "squashfs," "tar", "ubi", "vfat"]

    # Associate partitions in the hdimage with their images
    for pname, pattr in partitions.items():
        if "image" in pattr:
            piname = pattr["image"]
            if piname in images:
                # Found. Merge, initialising from template
                base = copy.deepcopy(partition_template)
                base["name"] = pname
                partitions[pname] = {**base, **images[piname], **pattr}

                # Tag image type
                for t in gtypes:
                    s = find_sections(t, partitions[pname])
                    if s:
                        partitions[pname]["type"] = t
                        # Invoke the processor for this type
                        if t in IMAGE_PROCESSORS:
                            attr = IMAGE_PROCESSORS[t](s)
                            if attr:
                                partitions[pname].update(attr)

                # Establish the actual size of the partition image rather than relying on
                # the size described by the genimage config (which may be expressed in
                # percent). The actual size is required for provisioning purposes.
                sz = get_artefact_size(piname)
                if sz:
                    partitions[pname]["size"] = sz

                # If this image has a sparse derivative, tag it
                for sname, sdata in simgs.items():
                    simg = sdata.get("android-sparse")
                    if piname == simg.get("image"):
                        partitions[pname]["simage"] = sname

    # Remove filesystem attributes from all partitions
    for part in partitions.values():
        fs_key = str(part.get("type", "")).lower()
        part.pop(fs_key, None)

    # Read the partition table from the image
    img_path = get_artefact_path(img_name, "IGconf_image_outputdir")
    try:
        res = subprocess.run(
                ["sfdisk", "--verify", "--json", img_path],
                capture_output=True,
                text=True,
                check=True
        )
    except Exception as e:
        raise RuntimeError(f"{e} Failed to read partition table from {img_path}")

    ptable = json.loads(res.stdout)

    # Populate genimage partition entries with GPT attributes
    def insert_gptattr(genimage_partitions, table_json):
        try:
            label = table_json.get("partitiontable", {}).get("label", "").lower()
        except Exception:
            label = ""
        if label != "gpt":
            return genimage_partitions

        disk_parts = table_json.get("partitiontable", {}).get("partitions", [])

        # Relies on ordering: genimage partitions are emitted in config order
        # and sfdisk JSON lists partitions in on-disk order. In this flow they
        # correspond positionally (1-1) provided in-partition-table != false.
        idx = 0
        for _pname, pdata in genimage_partitions.items():
            if idx >= len(disk_parts):
                break
            # Only populate partitions that are indicated as present by genimage
            if str(pdata.get("in-partition-table", "true")).lower() != "false":
                gpt_name = disk_parts[idx].get("name")
                if gpt_name:
                    pdata["partition-label"] = gpt_name
                gpt_uuid = disk_parts[idx].get("uuid")
                if gpt_uuid:
                    pdata["partition-uuid"] = gpt_uuid
            idx += 1

        return genimage_partitions

    # Assign GPT attributes from the partition table probe to each genimage partition
    partitions = insert_gptattr(partitions, ptable)

    # Prune non-essential partition table info
    pt = ptable.get("partitiontable")
    if isinstance(pt, dict):
        for key in ("partitions", "device", "unit", "firstlba", "lastlba", "sectorsize"):
            pt.pop(key, None)

    return (disk_attr, partitions, ptable)


def get_env_vars(prefix=None):
    if prefix:
        return {key: value for key,value in os.environ.items() if key.startswith(prefix)}
    return dict(os.environ)


# Returns IG config vars we want to bake into the json
def get_image_meta():
    vars = get_env_vars()
    image_vars = {}
    for key, value in vars.items():
        if key in IMAGE_KEYS:
            if key in IMAGE_KEY_TYPES:
                try:
                    image_vars[key] = IMAGE_KEY_TYPES[key](value)
                except ValueError:
                    image_vars[key] = None  # or handle error as needed
            else:
                image_vars[key] = value
    return image_vars


if __name__ == '__main__':
    parser = argparse.ArgumentParser(
            description='JSON layout generator')

    parser.add_argument("-g", "--genimage",
                        help="Path to genimage config file",
                        required=True)

    parser.add_argument("-m", "--provisionmap",
                        help="Path to the JSON provisioning map",
                        type=argparse.FileType('r'),
                        required=False)

    args = parser.parse_args()
    genimage_file = args.genimage;

    # Base info
    attributes, genimage_partitions, ptable = parse_genimage_config(genimage_file)
    partition_json = genimage_partitions

    top_template["IGmeta"] = get_image_meta()
    top_template["attributes"]["image-name"] = os.path.basename(attributes.get("image-name"))
    top_template["attributes"]["image-size"] = attributes.get("image-size")
    top_template["attributes"]["image-palign-bytes"] = attributes.get("image-palign")
    top_template["layout"]["partitiontable"] = ptable["partitiontable"]
    top_template["layout"]["partitionimages"] = partition_json
    if args.provisionmap:
        with args.provisionmap as f:
            top_template["layout"]["provisionmap"] = json.load(f)

    print(json.dumps(top_template, indent=4))
